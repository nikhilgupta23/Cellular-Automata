/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package javaapplication3;

import java.awt.Color;
import java.awt.Graphics;
import javax.swing.JComponent;
import javax.swing.JFrame;

class Grid extends JComponent {
    boolean map[][];
    Grid(boolean map[][])
    {
        this.map=map;
    }
//    @Override
//    public void update(Graphics g)
//    {
//        JavaApplication3 ja3=new JavaApplication3();
//        boolean map[][]=ja3.generateMap();
//        paint(g);
//    }
    @Override
    public void paint(Graphics g) { 
//        JavaApplication3 ja3=new JavaApplication3();
//        boolean map[][]=ja3.generateMap();
        int i;
        for (i = 0; i < 3000; i+=10)
        {
            for (int j = 0; j < 3000; j +=10)
            {
                
                if (map[i/10][j/10])
                    g.setColor(Color.black);
                else
                    g.setColor(Color.white);
                g.fillRect(i/2, j/2, 5, 5);  
            }
        }
//        g.setColor(Color.black); 
//        for (i = 0; i < 101; i++)
//            g.drawLine(0, i*10, 1000, i*10);
//        for (i = 0; i < 101; i++)
//            g.drawLine(i*10, 0, i*10, 1000);
    }
}
/**
 *
 * @author Nikhil Gupta
 */
public class JavaApplication3 {

    /**
     * @param args the command line arguments
     */
    
static int width=300,height=300;                                   /////////////////////////////////
boolean[][] cellmap = new boolean[width][height];

static float chanceToStartAlive = 0.45f;                           //////////////////////////////////
 
public static boolean[][] initialiseMap(boolean[][] map){
    for(int x=0; x<width; x++){
        for(int y=0; y<height; y++){
            if(Math.random() < chanceToStartAlive){
                map[x][y] = true;
            }
        }
    }
    return map;
}

public static boolean[][] doSimulationStep(boolean[][] oldMap){
    boolean[][] newMap = new boolean[width][height];
    //Loop over each row and column of the map
    for(int x=0; x<oldMap.length; x++){
        for(int y=0; y<oldMap[0].length; y++){
            int nbs = countAliveNeighbours(oldMap, x, y);
            //The new value is based on our simulation rules
            //First, if a cell is alive but has too few neighbours, kill it.
            if(oldMap[x][y]){
                if(nbs < 4){
                    newMap[x][y] = false;
                }
                else{
                    newMap[x][y] = true;
                }
            } //Otherwise, if the cell is dead now, check if it has the right number of neighbours to be 'born'
            else{
                if(nbs > 4){
                    newMap[x][y] = true;
                }
                else{
                    newMap[x][y] = false;
                }
            }
        }
    }
    return newMap;
}
//Returns the number of cells in a ring around (x,y) that are alive.
public static int countAliveNeighbours(boolean[][] map, int x, int y){
    int count = 0;
    for(int i=-1; i<2; i++){
        for(int j=-1; j<2; j++){
            int neighbour_x = x+i;
            int neighbour_y = y+j;
            //If we're looking at the middle point
            if(i == 0 && j == 0){
                //Do nothing, we don't want to add ourselves in!
            }
            //In case the index we're looking at it off the edge of the map
            else if(neighbour_x < 0 || neighbour_y < 0 || neighbour_x >= map.length || neighbour_y >= map[0].length){
                count = count + 1;
            }
            //Otherwise, a normal check of the neighbour
            else if(map[neighbour_x][neighbour_y]){
                count = count + 1;
            }
        }
    }
    return count;
}

public static boolean[][] generateMap(boolean map[][]){
    //Create a new map
//    boolean[][] map = new boolean[width][height];
    //Set up the map with random values
    
    //And now run the simulation for a set number of steps
        //////////////////////////////////////////Noofsteps
        boolean map1[][];
        map1 = doSimulationStep(map);
    
    return map1;
}

    public static void main(String[] args) throws InterruptedException {
        boolean map[][] = new boolean[width][height];
        map=initialiseMap(map);
        JFrame window = new JFrame();
        window.setSize(1366,768);
        window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        window.getContentPane().add(new Grid(map));
        window.setVisible(true);
        Thread.sleep(500);
        for(int i=0; i<10; i++){
            window.getContentPane().removeAll();
            map = doSimulationStep(map);
            window.getContentPane().add(new Grid(map));
            window.revalidate();
            window.repaint();
            Thread.sleep(50);
        }
        window.setVisible(true);
    }
    
}
